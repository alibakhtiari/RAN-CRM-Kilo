Nice â€” I updated the PRD to (A) keep it simple, (B) force a tested, compatible toolchain (pinned versions as of Oct 24, 2025), (C) implement your chosen suggestions (no DB trigger / client conflict handling, call-upload + on-demand fetch, realtime as core), and (D) include practical future-proofing practices (BOMs, CI checks, pinned Gradle/AGP). I kept it single-org and removed in-app admin since you said you'll use the Supabase Dashboard.

Below is the **final, simplified, future-proof PRD**. At the end I list a short set of practical recommendations to improve the PRD further (CI, dependency checks, tests, privacy).

Where I make version claims Iâ€™ve pinned them and cited authoritative sources (AGP, Kotlin, Compose, WorkManager, supabase-kt) so your build problems stop recurring.

---

# ðŸ“± PRD â€” Shared Contact & Call Log Sync (Kotlin Android + Supabase)

**Project:** Shared Contact CRM â€” Kotlin Android (single org)
**Version:** v3.0 (stable, future-proof)

---

## 1 â€” Goal (one line)

A single-organization Android app (Kotlin) that synchronizes a shared contacts list and call logs with Supabase, prevents duplicate phone numbers (older/winner rule enforced via server unique index + client conflict handling), uploads call logs from device â†’ server, and fetches call history on demand â€” realtime subscriptions keep the UI instantly up to date.

---

## 2 â€” Target platform & enforced toolchain (tested & compatible stack â€” pin these)

> Use these exact versions (tested together). Update only after verifying compatibility in CI.

* **Android Gradle Plugin (AGP):** `8.13.0`.

  * **Gradle (wrapper):** `8.13` (AGP 8.13 requires Gradle 8.13). ([Android Developers][1])
* **Kotlin:** `2.2.21` (Kotlin 2.2.x series is recommended). ([Kotlin][2])
* **Jetpack Compose (BOM):** use the Compose BOM for Compose 1.9.x (August 2025 BOM). ([Android Developers][3])
* **WorkManager:** `2.11.0` (latest stable background library). ([Android Developers][4])
* **Supabase Kotlin client:** `supabase-kt 3.2.5` (use this MPP client via Maven Central). ([Maven Repository][5])
* **Kotlinx.coroutines:** the stable 1.10.x series (match Kotlin version) â€” use the latest stable patch for your Kotlin release. ([GitHub][6])

**Why pin:** Gradle/AGP/Kotlin mismatches cause most build failures. Pin AGP+Gradle+Kotlin, use AndroidX/Compose BOMs to keep libraries aligned, and update in CI with compatibility tests before rolling to release.

---

## 3 â€” High level features (simplified)

1. **Single Org** â€” all data belongs to one org; no multi-org complexity.
2. **2 Screens only**

   * **Contacts** (main): list, search, add/edit (only owner or admin via dashboard), actions: Call / SMS / WhatsApp, 3-dot menu -> Edit/Delete, open Contact Detail â†’ call history.
   * **Settings**: sync interval, sync log, import-from-device (one-time), logout. (Admin actions are done in Supabase Dashboard.)
3. **Contacts sync**

   * Bi-directional but safe: Room is local source-of-truth for the app.
   * Upload local creations/edits to Supabase (INSERT with `ON CONFLICT DO NOTHING`; see conflict flow below).
   * Download server changes (incremental by `updated_at`), write to Room.
   * **Do NOT write server contacts back to Android ContactsProvider** (app keeps its own DB). Use Intents for call/SMS/WhatsApp.
4. **Call logs**

   * One-way: device â†’ server (upload new calls).
   * Call history for a contact is fetched **on demand**: `GET /calls?contact_id=eq.<uuid>&order=start_time.desc&limit=50`.
   * Optionally cache last N calls per contact locally for offline view.
5. **Conflict & duplicate rule**

   * Server enforces uniqueness: `UNIQUE (org_id, phone_normalized)`.
   * Client inserts with `ON CONFLICT DO NOTHING`. If 0 rows affected â†’ fetch server row â†’ delete local newer copy and adopt the server row. (Older first wins.)
6. **Realtime**

   * Subscribe to Supabase Realtime for `contacts` table when app is foreground; update Room on events.
   * WorkManager periodic sync is a fallback for missed events (offline/background).
7. **Local caching & offline**

   * Room stores contacts (and optional small calls cache).
   * Mark local rows `dirty` and `last_modified` to decide pushes.
8. **Security**

   * Supabase Auth for users (admin created in Dashboard).
   * RLS policies ensure users can only modify owned contacts and all org members can read.
   * No service_role key in the app.

---

## 4 â€” Simplified data model (key columns only)

**contacts**

* `id` (uuid PK)
* `org_id` (uuid, single org)
* `name` (text)
* `phone_raw` (text)
* `phone_normalized` (text, E.164)
* `created_by_user_id` (uuid)
* `created_at`, `updated_at`
* **unique index:** `(org_id, phone_normalized)`

**calls**

* `id` (uuid PK)
* `org_id`
* `contact_id` (nullable)
* `user_id` (uploader)
* `phone_normalized`
* `direction` (`incoming`/`outgoing`)
* `start_time`, `duration_seconds`
* created_at

---

## 5 â€” Sync details (concrete, minimal)

### Contact insert flow (client-side)

1. Normalize phone (libphonenumber) â†’ `phone_normalized`.
2. `INSERT ... RETURNING * ON CONFLICT (org_id, phone_normalized) DO NOTHING`

   * If the DB returns the row â†’ success â†’ mark local row as synced, store server `id`.
   * If 0 rows returned â†’ conflict â†’ `SELECT * FROM contacts WHERE org_id=$org AND phone_normalized=$phone` â†’ compare `created_at`:

     * If server is older â†’ delete local newer row and replace with server row in Room.
     * (If local is older â€” rare race â€” consider `UPDATE` with care only if owner rights exist.)
3. Log outcome in Sync Log.

### Contact update

* Use `UPDATE contacts SET ... WHERE id = $serverId` (requires server `id`).
* If changing phone, normalize and run the same conflict flow to avoid duplicates.

### Pull / merge

* Periodic: `SELECT * FROM contacts WHERE updated_at > :lastSync` â†’ upsert into Room.
* Realtime pushes will trigger smaller fetches for changed ids.

### Call logs

* Read CallLog provider periodically; dedupe locally by timestamp+number; batch `INSERT` to `calls` table.
* No full call list cached locally.

---

## 6 â€” Background & realtime strategy

* **WorkManager** for periodic sync (user-controlled interval, battery-friendly).
* **Realtime subscription** while app is foreground for instant updates (contacts).
* **On app resume / connectivity change** trigger incremental sync immediately.
* **Retry** failed uploads with exponential backoff; persist sync attempts to a small queue table in Room.

---

## 7 â€” Developer & build rules (to avoid version/Gradle problems)

* **Pin AGP + Gradle + Kotlin** in `settings.gradle.kts` / root `build.gradle.kts`:

  ```kotlin
  // gradle-wrapper.properties -> distributionUrl=...gradle-8.13-bin.zip
  plugins {
    id("com.android.application") version "8.13.0" apply false
    id("org.jetbrains.kotlin.android") version "2.2.21" apply false
  }
  ```

  (AGP 8.13 requires Gradle 8.13.) ([Android Developers][1])
* **Use AndroidX BOMs** (Compose BOM & Jetpack BOM) to keep AndroidX library versions consistent. Example (Kotlin DSL):

  ```kotlin
  implementation(platform("androidx.compose:compose-bom:2025.08.00"))
  implementation("io.github.jan-tennert.supabase:supabase-kt:3.2.5")
  implementation("androidx.work:work-runtime-ktx:2.11.0")
  ```

  (Use BOM to avoid version skew.) ([Maven Repository][5])
* **CI gating:** require successful build & instrumented tests before merging version bumps.
* **Dependabot / Renovate:** enable automated PRs but require team review before accepting updates.

---

## 8 â€” Privacy & Play Store compliance

* Request permissions only when necessary:

  * `READ_CALL_LOG` (for upload) â€” provide clear in-app explanation & privacy text.
  * `READ_CONTACTS` only for optional one-time import (explicit user action).
* Do not write to the device contacts provider.
* Include a privacy policy that explains call log sharing and retention.

---

## 9 â€” Success metrics (KPIs)

* No duplicate `phone_normalized` rows in DB (0 duplicates).
* Average contact propagation delay < 5s while app is open (Realtime).
* Sync success rate â‰¥ 98% across devices.
* Call upload latency < 10s average (when online).

---

## 10 â€” Minimal acceptance tests (suggested)

* Insert same phone from device A and B concurrently â†’ DB contains single row; client B deletes its local row and adopts server row.
* Add contact from A â†’ B receives via Realtime and shows in Room within 5s.
* Device uploads new calls â†’ server stores calls, fetching contact detail returns latest 50 calls.
* Import from ContactsProvider once â†’ Room receives imported contacts; no writes to ContactsProvider performed by app.

---

## 11 â€” Future proofing checklist (how to avoid version problems)

1. **Pin AGP + Gradle + Kotlin** (as above) and document the required Java JDK (JDK 17 per AGP 8.13). ([Android Developers][1])
2. **Use BOMs** for AndroidX/Compose; pin key non-Android dependencies (supabase-kt, libphonenumber) to tested versions. ([Android Developers][3])
3. **CI matrix test**: run builds with pinned versions immediately when bumping any of (Kotlin, AGP, Gradle, supabase-kt).
4. **Automated dependency PRs** but require human approval + CI green.
5. **Document local dev setup** clearly (Android Studio version corresponding to AGP).
6. **Run basic cross-device conflict tests** as part of nightly job.